---
title: 'Moving a bigger project from Cocoapods to Swift Package Manager'
description: >-
  What should you know before moving a bigger project to Swift Package Manager (SPM) from Cocoapods or other dependancy management system for iOS development.
date: '2022-08-31'
image: /images/wwdc22/apple_park.jpg
published: true
---

## Key points

I've moved a bigger project (ca. 300K SLOC, 16 external dependencies) to Swift Package Manager (SPM, SwiftPM) and would like to share my learnings for others following this path.

I would start with the key points and go in-depth in the end of the post.

### What I find good

- Swift as a first-class citizen: packages are defined in Swift (Package.swift)
- Local packages are working really well:
  - It is possible to add and remove files on the fly, Xcode can figure out the updates
  - Xcode understands the changes are happening and recalculating the dependencies if needed
- No need for `xcworkspace` any more
- Integration in Xcode: to change or add the dependency, select project, in the project on the right select the project -> Package Dependencies
- It is possible to use an automatically created Bundle.module reference when looking for the bundle resources inside of a module

### What I can tolerate, but good to know

- Frquent issues `Missing package product for ...`
- Package resolution takes a lot of time
- It is necessary to import Foundation and UIKit when they are used in your source files (this contributed)

### What can be improved

- SPM is doing full checkouts of dependencies repositories
- Dependencies are defined inside of the `project.pbxproj`
- A lot of warnings from the frameworks that are not possible to supress

### Was it worth it?

I think personally it was still worth it. SPM allows creating a better modular project structure, it is fast to add new packages and the package format is transparent to engineers.

## SPM cheat sheet

I summarized the practical points I've learned in a short cheatsheet.

### General information

Dependencies are defined in the project or workspace file: this is your old `Podfile`; pinned versions are saved in `Project.xcodeproj|Workspace.xcworkspace/xcshareddata/swiftpm/Package.resolved` â€” this is your `Podfile.lock`

#### Xcode error: Missing build product for `xxx`

Try closing Xcode, then executing in the project folder in the Terminal: `xcodebuild -resolvePackageDependencies -project <Project>.xcodeproj -scheme <Scheme>`, or `xcodebuild -resolvePackageDependencies -workspace <Workspace>.xcworkspace -scheme <Scheme>` if you are using a workspace.

#### Xcode: `Server SSH Fingerprint Failed to Verify`

Double-click the error message in Xcode and confirm the GitHub's fingerprint.

#### SPM is failing to fetch private packages

- Sign in to GitHub in Xcode -> Preferences -> Accounts
- Check if you have single and correct SSH key installed on your system
- Check if your SSH token is authorized with the SSO on the GitHub (if your company is using SSO)
- Check if Xcode is using the default SSH configuration (You can execute `defaults write com.apple.dt.Xcode IDEPackageSupportUseBuiltinSCM YES` to change this)
- Make sure ssh agent trust GitHub host (execute `ssh-keyscan github.com >> ~/.ssh/known_hosts`)

### General troubleshooting

- Update Xcode to latest release version
- Try File -> Packages -> Reset Package Cache
- You can try wiping the caches directory with `rm -rf ~/Library/Caches/org.swift.swiftpm/`

## In-depth

Once the basic things are out of the way, we can take a less shallow look on the SPM and the migration.

### Why SPM was introduced.

SPM was introduced in order to fill the gap in Swift ecosystem. Swift is intended as a general-purpose programming language, and the fact that there was no package manager on Linux created a need for SPM to be introduced.

On Mac, most prominent of SPM predecessors were Cocoapods and Carthage. I recall working on iOS projects before Cocoapods and it was a true nightmare. However, Cocoapods are based on a lot of magic, since they modify the project file and adjust build settings. In it's essence, Cocoapods is pulling the dependency sources and configures a separate Xcode project to build those sources in the way that a product of this build can be used in the main project. Then those two projects are connected with a Workspace, so Xcode can understand where the dependency library should be coming from.

Carthage is working in a very different way, building dependencies to frameworks, so those binary frameworks can be used by Xcode in the linking process.

SPM is much better integrated with Xcode and other build tools (as you might expect, since it's an Apple product). It is pulling the dependancy sources and creating an invisible project, much like Cocoapods would do.

### How to approach a migration to SPM

I went all-in with the migration. Our project was using Cocoapods for pulling in the dependencies, but also used local development pods in order to define logical modules of the applications. Some local pods were also depending on the third-party libraries fetched by Cocoapods. This made step-by-step migration not feasible.

#### Step 1: Current dependencies overlook

I've had to go with the following steps:

- List all external and internal dependencies
- Find which versions of those dependencies are providing SPM support
  - If a library versions used already supports SPM, we are good
  - If a library needs to be updated, check the release notes of the versions we need to go over. This can be done as a separate task, i.e. you can update to the needed version with your existing package manager and let it be tested for compatibility with your app.
  - If a library does not support SPM at all, fork it and introduce SPM to it. Then, when you are confident it is working, create a pull request from your fork to the upstream repo. Let other engineers enjoy the SPM support you've developed!

In the end you would need to have a list of dependencies and versions you would like to use.

#### Step 2: Remove Cocoapods (can be done later)

Cocoapods are usually deeply integrated with the project through the xcconfigs and build steps. If you would like to have a clean slate, it necessary to remove cocoapods before we would start integrating SPM packages. This can be easily achieved via [pod deintegrate](https://guides.cocoapods.org/terminal/commands.html#pod_deintegrate).

```
sudo gem install cocoapods-deintegrate cocoapods-clean
pod deintegrate
pod cache clean --all
```

You can also remove Podfile, Podfile.resolved and the workspace if you are not using it for anything else than Cocoapods.

If you would like to go step by step, you can always remove one dependency and add it via SPM.

#### Step 3: In Xcode, add the dependencies from step 1

- In Xcode, select File -> Add Packages... menu item
- Use top right search field to enter the git repo path for your dependency
- Let Xcode find the repository
- Select dependency rule. I recommend using exact versions to make sure your build are reproducible
- Click on "Add Package" and let Xcode do it's magic

#### Step 4: Migrating the local and in-house packages (if any)

Moving from Cocoapods [podspec manifest](https://guides.cocoapods.org/syntax/podspec.html) to a SPM [Package.swift](https://developer.apple.com/documentation/xcode/creating-a-standalone-swift-package-with-xcode) is a breese. I find it quite self explanatory, so please look on the example migration I've took for an internal package:

##### Cocoapods podspec

```ruby
Pod::Spec.new do |s|
  s.name         = "MyChatModule"
  s.version      = "1.0.0"
  s.summary      = "Module for MyChatModule"
  s.description  = ""
  s.homepage     = "https://www.deliveryhero.com"
  s.author       = { "Package Author" => "someone@deliveryhero.com" }
  s.platform     = :ios, "11"
  s.source       = { :git => "git@github.com:deliveryhero/MyChatModule.git", :tag => "#{s.version}" }
  s.swift_version = '5.0'
  
  s.static_framework = true

  s.dependency 'DependencyInjection', '1.0.0'
  s.dependency 'Networking', '1.0.0'
  s.dependency 'ExternalSDK', '5.2.1'
  
  s.source_files = "Sources/**/*.{swift}"
  s.resources = "Resources/**/*.{storyboard,xib,xcassets,png,pdf,ttf}"

  s.test_spec 'UnitTests' do |test_spec|
    test_spec.source_files = 'Tests/**/*.{swift}'
  end
end
```

##### SPM package manifest

```swift
// swift-tools-version:5.3
import PackageDescription

let package = Package(
    name: "MyChatModule",
    platforms: [
        .iOS(.v11)
    ],
    products: [
        .library(
            name: "MyChatModule",
            targets: ["MyChatModule"])
    ],
    dependencies: [
        .package(path: "../DependencyInjection"),
        .package(path: "../Networking"),
        .package(url: "https://github.com/ExternalSDKCompany/ExternalSDK-iOS.git", from: "5.2.1")
    ],
    targets: [
        .target(
            name: "MyChatModule",
            dependencies: ["Networking", 
                           "DependencyInjection", 
                           .product(name: "ExternalSDK", package: "ExternalSDK-ios")],
            path: "Sources",
            resources: [.process("Resources/Assets.xcassets"),
                        .process("Resources/Illustrations.xcassets"), 
                        .process("Resources/Icons.xcassets"), 
                        .copy("Resources/Fonts/font.ttf")]
        ),
        .testTarget(
            name: "MyChatModule-UnitTests",
            dependencies: ["MyChatModule"],
            path: "Tests"),
    ]
)
```

## Wishlist

Something that for me would be truly great to see in the SPM.

### Shallow clones of the dependencies

Truly low hanging fruit that would speed up the CI.

### Build artifacts caching

Wouldn't it be great not to rebuild the changes every time on your computer or on the CI?

There are multiple ways to achieve this. The easiest way would be to add an option for SPM to store the artifacts in a certain folder on the file system and try to read them from there. Certainly it is much more complex than that, but at least for a given dependency version and a given Xcode version it should be entirely possible to cache all the build products.

In the hermetic build systems like Bazel it is possible to collect all the arguments build step needs and avoid other side effects. Using this feature, it is possible to cache the build artifacts for the given input and reuse them in case the inputs (source files, configurations, libraries) were not changed.

I believe work on this topic is already happening inside of the SPM team, so we would be able to benefit from it in the future.

## Nota Bene: SPM Slack

If you have ideas about SPM or would like to participate in the discussion about it, you can register for [SPM Unofficial Slack](https://swift-package-manager.herokuapp.com). Some of the _best_ Apple engineers are also present there.
